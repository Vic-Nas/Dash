<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Progressive Mode - Dash Arena</title>
  <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, sans-serif;
      background: #0d0f1a;
      color: #e6e6e6;
      overflow: hidden;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 20px;
    }
    #gameCanvas {
      border: 2px solid #2a2f6b;
      background: #121428;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(18,20,40,0.9);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f6b;
      min-width: 200px;
      display: block;
    }
    .stat {
      margin-bottom: 8px;
      font-size: 14px;
    }
    .stat-label {
      color: #9ca3af;
      margin-right: 8px;
    }
    .stat-value {
      color: #fff;
      font-weight: 600;
    }
    #gameOver {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(18,20,40,0.98);
      padding: 40px;
      border-radius: 12px;
      border: 2px solid #2a2f6b;
      text-align: center;
      min-width: 400px;
      z-index: 1000;
    }
    #gameOver h2 {
      margin-bottom: 16px;
      font-size: 28px;
      color: #5b7bff;
    }
    #gameOver .result {
      margin-bottom: 24px;
    }
    #gameOver .result-item {
      margin: 8px 0;
      font-size: 16px;
    }
    #gameOver button {
      background: #2a2f6b;
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 15px;
      margin: 0 8px;
    }
    #gameOver button:hover {
      background: #3940a3;
    }
    #mobile-controls {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, 70px);
      grid-template-rows: repeat(3, 70px);
      gap: 8px;
      justify-content: center;
    }
    #mobile-controls button {
      font-size: 24px;
      padding: 0;
      border-radius: 10px;
      border: 2px solid #2a2f6b;
      background: rgba(42, 47, 107, 0.8);
      color: white;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #mobile-controls button:active {
      background: rgba(57, 64, 163, 0.9);
    }
    .btn-up { grid-column: 2; grid-row: 1; }
    .btn-left { grid-column: 1; grid-row: 2; }
    .btn-down { grid-column: 2; grid-row: 2; }
    .btn-right { grid-column: 3; grid-row: 2; }
    .btn-escape {
      grid-column: 2;
      grid-row: 3;
      font-size: 14px;
      background: rgba(239, 68, 68, 0.8);
    }
    .btn-escape:active {
      background: rgba(239, 68, 68, 1);
    }
    #levelSelector {
      text-align: center;
      max-width: 800px;
      width: 100%;
    }
    #levelSelector h1 {
      font-size: 48px;
      margin-bottom: 16px;
      color: #5b7bff;
    }
    #levelGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
      margin: 32px 0;
      max-height: 60vh;
      overflow-y: auto;
      padding: 20px;
      background: rgba(18,20,40,0.5);
      border-radius: 12px;
    }
    .level-btn {
      padding: 20px;
      background: #2a2f6b;
      border: 2px solid #3940a3;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      transition: all 0.2s;
    }
    .level-btn:hover:not(.locked) {
      background: #3940a3;
      transform: scale(1.05);
    }
    .level-btn.locked {
      background: #1a1d2e;
      border-color: #2a2f6b;
      color: #6b7280;
      cursor: not-allowed;
      opacity: 0.5;
    }
    .level-btn.completed {
      background: #10b981;
      border-color: #059669;
    }
    .level-info {
      margin-top: 24px;
      padding: 16px;
      background: rgba(42, 47, 107, 0.3);
      border-radius: 8px;
      font-size: 14px;
      color: #9ca3af;
    }
    @media (max-width: 768px) {
      #hud {
        position: static;
        margin-top: 10px;
        padding: 12px;
        min-width: 150px;
        font-size: 12px;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        gap: 8px;
      }
      .stat {
        margin-bottom: 0;
        font-size: 12px;
      }
      #soundBtn {
        flex: 1 1 100%;
      }
      #gameOver {
        min-width: 90%;
        padding: 20px;
      }
      #levelGrid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 8px;
      }
      .level-btn {
        padding: 15px;
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="600" height="600" style="display:none;"></canvas>
    
    <div id="hud" style="display:none;">
      <div class="stat">
        <span class="stat-label">Level:</span>
        <span class="stat-value" id="currentLevel">1</span>
      </div>
      <div class="stat">
        <span class="stat-label">Bots Left:</span>
        <span class="stat-value" id="botsLeft">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Eliminated:</span>
        <span class="stat-value" id="botsEliminated">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Time:</span>
        <span class="stat-value" id="time">0s</span>
      </div>
      <button
        onclick="toggleSound()"
        id="soundBtn"
        style="
          width:100%;
          margin-top:8px;
          padding:8px;
          background:#2a2f6b;
          border:none;
          border-radius:6px;
          color:#fff;
          cursor:pointer;
          font-size:13px;
        "
      >
        ðŸ”Š Sound ON
      </button>
    </div>

    <div id="mobile-controls" style="display:none;">
      <button class="btn-up" onmousedown="pressKey('ArrowUp')" onmouseup="releaseKey('ArrowUp')" ontouchstart="pressKey('ArrowUp')" ontouchend="releaseKey('ArrowUp')">â–²</button>
      <button class="btn-left" onmousedown="pressKey('ArrowLeft')" onmouseup="releaseKey('ArrowLeft')" ontouchstart="pressKey('ArrowLeft')" ontouchend="releaseKey('ArrowLeft')">â—€</button>
      <button class="btn-down" onmousedown="pressKey('ArrowDown')" onmouseup="releaseKey('ArrowDown')" ontouchstart="pressKey('ArrowDown')" ontouchend="releaseKey('ArrowDown')">â–¼</button>
      <button class="btn-right" onmousedown="pressKey('ArrowRight')" onmouseup="releaseKey('ArrowRight')" ontouchstart="pressKey('ArrowRight')" ontouchend="releaseKey('ArrowRight')">â–¶</button>
      <button class="btn-escape" onclick="endGame()">ESC</button>
    </div>

    <div id="levelSelector">
      <h1>Progressive Mode</h1>
      <p style="color:#9ca3af;margin-bottom:16px;">Choose Your Level</p>
      <div id="levelGrid"></div>
      <div class="level-info">
        <div>ðŸ’° Cost: {{ costPerAttempt }} coins per attempt</div>
        <div>ðŸŽ¯ Goal: Eliminate all bots to win</div>
        <div>ðŸ’Ž Reward: Level Ã— 10 coins on victory</div>
        <div>ðŸ”’ Unlock levels by beating previous ones</div>
      </div>
      <button onclick="location.href='/'" style="margin-top:20px;background:#2a2f6b;color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;">Back to Dashboard</button>
    </div>
  </div>

  <div id="gameOver">
    <h2 id="gameOverTitle">Game Over</h2>
    <div class="result">
      <div class="result-item">Level: <strong id="finalLevel">1</strong></div>
      <div class="result-item">Bots Eliminated: <strong id="finalBotsEliminated">0</strong></div>
      <div class="result-item">Time: <strong id="finalTime">0s</strong></div>
      <div class="result-item" id="savingStatus" style="color:#f59e0b;margin-top:16px;">Saving...</div>
    </div>
    <div id="gameOverActions" style="display:none;">
      <button onclick="backToLevelSelect()">Level Select</button>
      <button onclick="location.href='/'">Dashboard</button>
    </div>
  </div>

  <script>
        // Replay recording
        var replayRecorder = {
          frames: [],
          recording: true,
          frameDuration: TICK_RATE,
          recordFrame: function() {
            if (!this.recording) return;
            this.frames.push({
              gridSize: GRID_SIZE,
              player: {
                x: gameState.player.x,
                y: gameState.player.y,
                direction: gameState.player.direction,
                alive: gameState.player.alive
              },
              bots: gameState.bots.map(bot => ({
                x: bot.x,
                y: bot.y,
                direction: bot.direction,
                alive: bot.alive
              })),
              level: gameState.level,
              botsEliminated: gameState.botsEliminated
            });
          },
          getReplayData: function() {
            return {
              frames: this.frames,
              frameDuration: this.frameDuration,
              mode: 'progressive'
            };
          }
        };
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');

    var MAX_LEVEL = {{ maxLevel }};
    var COST_PER_ATTEMPT = {{ costPerAttempt }};
    var HIGHEST_LEVEL = {{ profile.progressiveHighestLevel }};
    var CURRENT_BALANCE = {{ profile.coins }};

    var GRID_SIZE = 20;
    var CELL_SIZE = 0;
    var TICK_RATE = 150;
    var botMoveCounter = 0;
    var BOT_MOVE_EVERY = 3; 

    var gameState = {
      player: null,
      bots: [],
      level: 1,
      botsEliminated: 0,
      startTime: 0,
      gameOver: false,
      won: false
    };

    var currentDirection = 'UP';
    var nextDirection = 'UP';
    var gameStarted = false;
    var gameLoopInterval = null;
    var botImage = null;
    var playerImage = null;

    class GameAudio {
      constructor() {
        this.audioContext = null;
        this.enabled = true;
      }
      
      init() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }
      
      playMove() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 400;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.05);
      }
      
      playHit() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 150;
        oscillator.type = 'sawtooth';
        
        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.15);
      }
      
      playScore() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.2);
      }
      
      playGameOver() {
        if (!this.enabled) return;
        this.init();
        
        const notes = [392, 330, 262];
        const noteLength = 0.2;
        
        notes.forEach((freq, i) => {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.frequency.value = freq;
          oscillator.type = 'sine';
          
          const startTime = this.audioContext.currentTime + (i * noteLength);
          gainNode.gain.setValueAtTime(0.2, startTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteLength);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + noteLength);
        });
      }
      
      toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
      }
    }

    const gameAudio = new GameAudio();

    function adjustCanvasSize() {
      var maxWidth = window.innerWidth - 40;
      var maxHeight = window.innerHeight - 400;
      var size = Math.min(600, maxWidth, maxHeight);
      
      canvas.width = size;
      canvas.height = size;
      
      if (size < 400) {
        GRID_SIZE = 15;
      } else if (size < 500) {
        GRID_SIZE = 18;
      } else {
        GRID_SIZE = 20;
      }
      
      CELL_SIZE = canvas.width / GRID_SIZE;
    }

    function createBotImage() {
      var size = 128;
      var img = document.createElement('canvas');
      img.width = size;
      img.height = size;
      var c = img.getContext('2d');
      
      c.fillStyle = '#ef4444';
      c.strokeStyle = '#fff';
      c.lineWidth = 4;
      c.lineJoin = 'miter';
      c.lineCap = 'square';
      
      c.beginPath();
      c.moveTo(size * 0.5, size * 0.15);
      c.lineTo(size * 0.85, size * 0.5);
      c.lineTo(size * 0.65, size * 0.5);
      c.lineTo(size * 0.65, size * 0.85);
      c.lineTo(size * 0.35, size * 0.85);
      c.lineTo(size * 0.35, size * 0.5);
      c.lineTo(size * 0.15, size * 0.5);
      c.closePath();
      c.fill();
      c.stroke();
      
      return img;
    }

    function createPlayerImage() {
      var size = 128;
      var img = document.createElement('canvas');
      img.width = size;
      img.height = size;
      var c = img.getContext('2d');
      
      c.fillStyle = '#5b7bff';
      c.strokeStyle = '#fff';
      c.lineWidth = 4;
      c.lineJoin = 'miter';
      c.lineCap = 'square';
      
      c.beginPath();
      c.moveTo(size * 0.5, size * 0.15);
      c.lineTo(size * 0.85, size * 0.5);
      c.lineTo(size * 0.65, size * 0.5);
      c.lineTo(size * 0.65, size * 0.85);
      c.lineTo(size * 0.35, size * 0.85);
      c.lineTo(size * 0.35, size * 0.5);
      c.lineTo(size * 0.15, size * 0.5);
      c.closePath();
      c.fill();
      c.stroke();
      
      return img;
    }

    document.addEventListener('keydown', function(e) {
      if (!gameStarted || gameState.gameOver) return;

      if (e.key === 'Escape') {
        endGame();
        return;
      }

      var key = e.key.toUpperCase();
      if (key === 'W' || key === 'ARROWUP') {
        nextDirection = 'UP';
        gameAudio.playMove();
      }
      else if (key === 'S' || key === 'ARROWDOWN') {
        nextDirection = 'DOWN';
        gameAudio.playMove();
      }
      else if (key === 'A' || key === 'ARROWLEFT') {
        nextDirection = 'LEFT';
        gameAudio.playMove();
      }
      else if (key === 'D' || key === 'ARROWRIGHT') {
        nextDirection = 'RIGHT';
        gameAudio.playMove();
      }
    });

    function initGame(level) {
      adjustCanvasSize();
      
      var centerX = Math.floor(GRID_SIZE / 2);
      var centerY = Math.floor(GRID_SIZE / 2);
      
      gameState.level = level;
      gameState.player = {
        x: centerX,
        y: centerY,
        direction: 'UP',
        alive: true
      };
      gameState.bots = [];
      gameState.botsEliminated = 0;
      gameState.startTime = Date.now();
      gameState.gameOver = false;
      gameState.won = false;
      
      currentDirection = 'UP';
      nextDirection = 'UP';
      botMoveCounter = 0;
      
      botImage = createBotImage();
      playerImage = createPlayerImage();
      
      for (var i = 0; i < level; i++) {
        spawnBot();
      }
      
      startGameLoop();
    }

    function spawnBot() {
      var x, y;
      var attempts = 0;
      
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        attempts++;
      } while (
        attempts < 100 &&
        isPositionOccupied(x, y)
      );
      
      if (attempts < 100) {
        gameState.bots.push({
          x: x,
          y: y,
          direction: ['UP', 'DOWN', 'LEFT', 'RIGHT'][Math.floor(Math.random() * 4)],
          alive: true
        });
      }
    }

    function isPositionOccupied(x, y) {
      if (gameState.player.x === x && gameState.player.y === y) return true;
      return gameState.bots.some(function(bot) {
        return bot.alive && bot.x === x && bot.y === y;
      });
    }

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      
      gameLoopInterval = setInterval(function() {
        if (!gameState.gameOver) {
          updateGame();
          render();
          updateHUD();
        }
      }, TICK_RATE);
    }

    function updateGame() {
      currentDirection = nextDirection;
      gameState.player.direction = currentDirection;
      var newPlayerX = gameState.player.x;
      var newPlayerY = gameState.player.y;
      if (currentDirection === 'UP') newPlayerY--;
      else if (currentDirection === 'DOWN') newPlayerY++;
      else if (currentDirection === 'LEFT') newPlayerX--;
      else if (currentDirection === 'RIGHT') newPlayerX++;
      // Prevent player from moving out of bounds
      if (newPlayerX < 0 || newPlayerX >= GRID_SIZE || newPlayerY < 0 || newPlayerY >= GRID_SIZE) {
        replayRecorder.recordFrame();
        return; // Don't move, just exit
      }
      // Check for head-on collision BEFORE moving - this blocks movement
      var headOnCollision = false;
      for (var i = 0; i < gameState.bots.length; i++) {
        var bot = gameState.bots[i];
        if (!bot.alive) continue;
        // Only check if we're trying to move into the bot's cell
        if (newPlayerX === bot.x && newPlayerY === bot.y) {
          var dx = newPlayerX - gameState.player.x; // Direction player is moving
          var dy = newPlayerY - gameState.player.y;
          // Check if bot is facing towards the player
          var botFacingPlayer = false;
          if (dx === 0 && dy === -1 && bot.direction === 'DOWN') botFacingPlayer = true; // Player moving UP, bot facing DOWN
          if (dx === 0 && dy === 1 && bot.direction === 'UP') botFacingPlayer = true;    // Player moving DOWN, bot facing UP
          if (dx === -1 && dy === 0 && bot.direction === 'RIGHT') botFacingPlayer = true; // Player moving LEFT, bot facing RIGHT
          if (dx === 1 && dy === 0 && bot.direction === 'LEFT') botFacingPlayer = true;   // Player moving RIGHT, bot facing LEFT
          if (botFacingPlayer) {
            headOnCollision = true;
            replayRecorder.recordFrame();
            return; // Block movement completely
          }
        }
      }
      // MOVE PLAYER FIRST
      gameState.player.x = newPlayerX;
      gameState.player.y = newPlayerY;
      // Check for side/back hits on bots - IMMEDIATELY after player moves
      for (var i = 0; i < gameState.bots.length; i++) {
        var bot = gameState.bots[i];
        if (!bot.alive) continue;
        if (gameState.player.x === bot.x && gameState.player.y === bot.y) {
          // Player is now on bot's position - check if it's side or back
          var hitBack = false;
          if (currentDirection === 'UP' && bot.direction === 'UP') hitBack = true;
          if (currentDirection === 'DOWN' && bot.direction === 'DOWN') hitBack = true;
          if (currentDirection === 'LEFT' && bot.direction === 'LEFT') hitBack = true;
          if (currentDirection === 'RIGHT' && bot.direction === 'RIGHT') hitBack = true;
          // Check if player hits bot from side
          var hitSide = false;
          if (currentDirection === 'UP' && (bot.direction === 'LEFT' || bot.direction === 'RIGHT')) hitSide = true;
          if (currentDirection === 'DOWN' && (bot.direction === 'LEFT' || bot.direction === 'RIGHT')) hitSide = true;
          if (currentDirection === 'LEFT' && (bot.direction === 'UP' || bot.direction === 'DOWN')) hitSide = true;
          if (currentDirection === 'RIGHT' && (bot.direction === 'UP' || bot.direction === 'DOWN')) hitSide = true;
          if (hitBack || hitSide) {
            bot.alive = false;
            gameState.botsEliminated++;
            gameAudio.playScore();
          }
        }
      }
      // Check if won
      var aliveBotsCount = gameState.bots.filter(function(b) { return b.alive; }).length;
      if (aliveBotsCount === 0) {
        gameState.won = true;
        endGame();
        replayRecorder.recordFrame();
        return;
      }
      // NOW move bots (only if they're still alive)
      botMoveCounter++;
      var shouldMoveBots = (botMoveCounter >= BOT_MOVE_EVERY);
      if (shouldMoveBots) {
        botMoveCounter = 0;
      }
      if (!shouldMoveBots) {
        replayRecorder.recordFrame();
        return; // Skip bot movement this tick
      }
      var botNewPositions = [];
      for (var i = 0; i < gameState.bots.length; i++) {
        var bot = gameState.bots[i];
        if (!bot.alive) {
          botNewPositions.push(null);
          continue;
        }
        var botMove = calculateBotMove(bot);
        botNewPositions.push(botMove);
      }
      // Apply bot movements
      for (var i = 0; i < gameState.bots.length; i++) {
        var bot = gameState.bots[i];
        if (!bot.alive || !botNewPositions[i]) continue;
        var move = botNewPositions[i];
        // Check if bot is moving into player position
        if (move.x === gameState.player.x && move.y === gameState.player.y) {
          // Check if this would be a head-on collision (bot facing player)
          var dx = move.x - bot.x;
          var dy = move.y - bot.y;
          var isHeadOn = false;
          if (dx === 0 && dy === -1 && gameState.player.direction === 'DOWN') isHeadOn = true;
          if (dx === 0 && dy === 1 && gameState.player.direction === 'UP') isHeadOn = true;
          if (dx === -1 && dy === 0 && gameState.player.direction === 'RIGHT') isHeadOn = true;
          if (dx === 1 && dy === 0 && gameState.player.direction === 'LEFT') isHeadOn = true;
          if (isHeadOn) {
            // Don't move the bot - it's blocked too
            continue;
          } else {
            // Bot attacks from side/back - player dies
            gameState.player.alive = false;
            gameAudio.playHit();
            endGame();
            replayRecorder.recordFrame();
            return;
          }
        }
        var collision = false;
        for (var j = 0; j < gameState.bots.length; j++) {
          if (i === j || !gameState.bots[j].alive) continue;
          if (move.x === gameState.bots[j].x && move.y === gameState.bots[j].y) {
            collision = true;
            break;
          }
        }
        if (!collision) {
          bot.x = move.x;
          bot.y = move.y;
          bot.direction = move.direction;
        }
      }
      replayRecorder.recordFrame();
    }

    function calculateBotMove(bot) {
      var playerX = gameState.player.x;
      var playerY = gameState.player.y;
      
      var dx = playerX - bot.x;
      var dy = playerY - bot.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      
      var moves = [
        { dx: 0, dy: -1, dir: 'UP' },
        { dx: 0, dy: 1, dir: 'DOWN' },
        { dx: -1, dy: 0, dir: 'LEFT' },
        { dx: 1, dy: 0, dir: 'RIGHT' }
      ];

      // Prevent bots from reversing direction
      var opposite = {
        'UP': 'DOWN',
        'DOWN': 'UP',
        'LEFT': 'RIGHT',
        'RIGHT': 'LEFT'
      };

      var validMoves = [];
      for (var i = 0; i < moves.length; i++) {
        var m = moves[i];
        var isReverse = bot.direction && m.dir === opposite[bot.direction];
        if (isReverse) continue;

        var newX = bot.x + m.dx;
        var newY = bot.y + m.dy;

        if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) continue;

        var occupied = gameState.bots.some(function(b) {
          return b.alive && b !== bot && b.x === newX && b.y === newY;
        });

        if (occupied) continue;

        var newDx = playerX - newX;
        var newDy = playerY - newY;
        var newDistance = Math.sqrt(newDx * newDx + newDy * newDy);

        // Always chase the player aggressively
        var priority = 0;
        if (newDistance < distance) {
          priority = 100 - newDistance; // Prefer moves that get closer
        } else {
          priority = 10; // Lower priority for moves that don't get closer
        }

        validMoves.push({ x: newX, y: newY, direction: m.dir, priority: priority });
      }

      if (validMoves.length === 0) {
        return { x: bot.x, y: bot.y, direction: bot.direction };
      }
      
      validMoves.sort(function(a, b) { return b.priority - a.priority; });
      return validMoves[0];
    }

    function render() {
      ctx.fillStyle = '#121428';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = '#23264a';
      ctx.lineWidth = 1;
      for (var i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }
      
      for (var i = 0; i < gameState.bots.length; i++) {
        var bot = gameState.bots[i];
        if (!bot.alive) continue;
        
        var bx = bot.x * CELL_SIZE + CELL_SIZE / 2;
        var by = bot.y * CELL_SIZE + CELL_SIZE / 2;
        
        ctx.save();
        ctx.translate(bx, by);
        
        var angle = 0;
        if (bot.direction === 'DOWN') angle = Math.PI;
        else if (bot.direction === 'LEFT') angle = -Math.PI / 2;
        else if (bot.direction === 'RIGHT') angle = Math.PI / 2;
        
        ctx.rotate(angle);
        
        var drawSize = CELL_SIZE * 1.5;
        ctx.drawImage(botImage, -drawSize/2, -drawSize/2, drawSize, drawSize);
        
        ctx.restore();
      }
      
      if (gameState.player.alive) {
        var px = gameState.player.x * CELL_SIZE + CELL_SIZE / 2;
        var py = gameState.player.y * CELL_SIZE + CELL_SIZE / 2;
        
        ctx.save();
        ctx.translate(px, py);
        
        var angle = 0;
        if (currentDirection === 'DOWN') angle = Math.PI;
        else if (currentDirection === 'LEFT') angle = -Math.PI / 2;
        else if (currentDirection === 'RIGHT') angle = Math.PI / 2;
        
        ctx.rotate(angle);
        
        var drawSize = CELL_SIZE * 1.5;
        ctx.drawImage(playerImage, -drawSize/2, -drawSize/2, drawSize, drawSize);
        
        ctx.restore();
      }
    }

    function updateHUD() {
      document.getElementById('currentLevel').textContent = gameState.level;
      var aliveBotsCount = gameState.bots.filter(function(b) { return b.alive; }).length;
      document.getElementById('botsLeft').textContent = aliveBotsCount;
      document.getElementById('botsEliminated').textContent = gameState.botsEliminated;
      
      var elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('time').textContent = elapsed + 's';
    }

    function getCookie(name) {
      let value = '; ' + document.cookie;
      let parts = value.split('; ' + name + '=');
      if (parts.length === 2) return parts.pop().split(';').shift();
    }

    async function saveGameResults() {
      var survivalTime = Math.floor((Date.now() - gameState.startTime) / 1000);
      
      try {
        const response = await fetch('/matches/save-progressive-run/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            level: gameState.level,
            botsEliminated: gameState.botsEliminated,
            won: gameState.won,
            survivalTime: survivalTime,
            finalGridState: {
              player: gameState.player,
              bots: gameState.bots
            },
            replayData: replayRecorder.getReplayData() // ADD THIS
          })
        });

        const data = await response.json();

        if (data.success) {
          var statusEl = document.getElementById('savingStatus');
          if (data.won) {
            statusEl.style.color = '#10b981';
            statusEl.textContent = 'âœ… Victory! Earned: +' + data.coinsEarned + ' coins';
            
            if (data.newHighestLevel) {
              statusEl.textContent += ' ðŸ† NEW RECORD!';
            }
            
            HIGHEST_LEVEL = Math.max(HIGHEST_LEVEL, gameState.level);
          } else {
            statusEl.style.color = '#ef4444';
            statusEl.textContent = 'ðŸ’€ Defeated';
          }
          
          CURRENT_BALANCE = data.newBalance;
        } else {
          var statusEl = document.getElementById('savingStatus');
          statusEl.style.color = '#ef4444';
          statusEl.textContent = 'âŒ Error saving: ' + (data.error || 'Unknown error');
        }
      } catch (error) {
        var statusEl = document.getElementById('savingStatus');
        statusEl.style.color = '#ef4444';
        statusEl.textContent = 'âŒ Error saving: ' + error.message;
      } finally {
        document.getElementById('gameOverActions').style.display = 'block';
      }
    }

    function endGame() {
      if (gameState.gameOver) return;
      gameState.gameOver = true;
      
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      
      showGameOver();
    }

    function showGameOver() {
      gameAudio.playGameOver();
      
      var title = gameState.won ? 'ðŸŽ‰ Victory!' : 'ðŸ’€ Defeated';
      document.getElementById('gameOverTitle').textContent = title;
      document.getElementById('finalLevel').textContent = gameState.level;
      document.getElementById('finalBotsEliminated').textContent = gameState.botsEliminated;
      var elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('finalTime').textContent = elapsed + 's';
      
      document.getElementById('savingStatus').style.color = '#f59e0b';
      document.getElementById('savingStatus').textContent = 'Saving...';
      document.getElementById('gameOverActions').style.display = 'none';
      
      document.getElementById('gameOver').style.display = 'block';
      
      saveGameResults();
    }

    function startGame(level) {
      if (CURRENT_BALANCE < COST_PER_ATTEMPT) {
        alert('Insufficient coins! Need ' + COST_PER_ATTEMPT + ' coins.');
        return;
      }
      
      CURRENT_BALANCE -= COST_PER_ATTEMPT;
      
      gameStarted = true;
      document.getElementById('levelSelector').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'block';
      document.getElementById('hud').style.display = 'block';
      document.getElementById('mobile-controls').style.display = 'grid';
      initGame(level);
    }

    function backToLevelSelect() {
      gameStarted = false;
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'none';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('mobile-controls').style.display = 'none';
      document.getElementById('levelSelector').style.display = 'block';
      
      renderLevelGrid();
    }

    function pressKey(key) {
      document.dispatchEvent(new KeyboardEvent('keydown', { key: key }));
    }

    function releaseKey(key) {
      document.dispatchEvent(new KeyboardEvent('keyup', { key: key }));
    }

    function renderLevelGrid() {
      var grid = document.getElementById('levelGrid');
      grid.innerHTML = '';

      for (var i = 1; i <= MAX_LEVEL; i++) {
        var btn = document.createElement('button');
        btn.className = 'level-btn';
        btn.textContent = i;

        var isCompleted = i <= HIGHEST_LEVEL;
        var isLocked = i > HIGHEST_LEVEL + 1;

        if (isCompleted) {
          btn.classList.add('completed');
          btn.title = 'Completed âœ“';
        } else if (isLocked) {
          btn.classList.add('locked');
          btn.title = 'Locked ðŸ”’';
        } else {
          btn.title = 'Click to play - ' + COST_PER_ATTEMPT + ' coins';
        }

        if (!isLocked) {
          (function(level) {
            btn.onclick = function() {
              startGame(level);
            };
          })(i);
        }

        grid.appendChild(btn);
      }
    }

    window.addEventListener('resize', function() {
      if (gameStarted && !gameState.gameOver) {
        adjustCanvasSize();
        render();
      }
    });

    function toggleSound() {
      var enabled = gameAudio.toggle();
      document.getElementById('soundBtn').textContent = enabled ? 'ðŸ”Š Sound ON' : 'ðŸ”‡ Sound OFF';
    }

    renderLevelGrid();
  </script>
</body>
</html>