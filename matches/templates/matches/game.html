<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Solo Mode - Dash Arena</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0;}
    body{font-family:system-ui,sans-serif;background:#0d0f1a;color:#e6e6e6;overflow:hidden;}
    #gameContainer{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;padding:20px;}
    #gameCanvas{border:2px solid #2a2f6b;background:#121428;box-shadow:0 4px 20px rgba(0,0,0,0.5);}
    #hud{position:absolute;top:20px;left:20px;background:rgba(18,20,40,0.9);padding:16px;border-radius:8px;border:1px solid #2a2f6b;min-width:200px;}
    .stat{margin-bottom:8px;font-size:14px;}
    .stat-label{color:#9ca3af;margin-right:8px;}
    .stat-value{color:#fff;font-weight:600;}
    .score-positive{color:#10b981;}
    .score-negative{color:#ef4444;}
    #gameOver{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(18,20,40,0.98);padding:40px;border-radius:12px;border:2px solid #2a2f6b;text-align:center;min-width:400px;z-index:1000;}
    #gameOver h2{margin-bottom:16px;font-size:28px;color:#5b7bff;}
    #gameOver .result{margin-bottom:24px;}
    #gameOver .result-item{margin:8px 0;font-size:16px;}
    #gameOver button{background:#2a2f6b;color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:15px;margin:0 8px;}
    #gameOver button:hover{background:#3940a3;}
    .controls{margin-top:16px;color:#9ca3af;font-size:13px;}
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="600" height="600" style="display:none;"></canvas>
    <div id="startScreen" style="text-align:center;">
      <h1 style="font-size:48px;margin-bottom:16px;color:#5b7bff;">Solo Mode</h1>
      <p style="color:#9ca3af;margin-bottom:32px;font-size:18px;">Use Arrow Keys or WASD to move ‚Ä¢ Press ESC to quit and save</p>
      <button onclick="startGame()" style="background:#2a2f6b;color:#fff;border:none;padding:16px 48px;border-radius:8px;cursor:pointer;font-size:20px;font-weight:600;margin-top:16px;">Start Game</button>
      <div style="margin-top:32px;color:#9ca3af;font-size:14px;">
        <div style="margin:8px 0;color:#10b981;">‚úÖ Each wall spawned: +1 point</div>
        <div style="margin:8px 0;color:#ef4444;">‚ùå Each wall/edge hit: -1 point</div>
        <div style="margin:16px 0;color:#ef4444;font-weight:600;">‚ö†Ô∏è Game Over at -50 points</div>
        <div style="margin:16px 0;color:#fbbf24;">üéÆ Press ESC anytime to quit and save your score</div>
      </div>
    </div>
    <div class="controls" style="display:none;" id="controls">Arrow Keys or WASD to change direction ‚Ä¢ ESC to quit and save</div>
  </div>

  <div id="hud" style="display:none;">
    <div class="stat">
      <span class="stat-label">Balance:</span>
      <span class="stat-value" id="balance">{{ profile.coins|floatformat:0 }}</span>
    </div>
    <div class="stat">
      <span class="stat-label">Current Score:</span>
      <span class="stat-value" id="currentScore">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Walls Survived:</span>
      <span class="stat-value" id="wallsSurvived">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Walls Hit:</span>
      <span class="stat-value" id="wallsHit">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Time:</span>
      <span class="stat-value" id="time">0s</span>
    </div>
    <div class="stat">
      <span class="stat-label">High Score:</span>
      <span class="stat-value" id="highScore">{{ profile.soloHighScore }}</span>
    </div>
  </div>

  <div id="gameOver">
    <h2>Game Over</h2>
    <div class="result">
      <div class="result-item">Final Score: <strong id="finalScore">0</strong></div>
      <div class="result-item">Walls Survived: <strong id="finalWalls">0</strong></div>
      <div class="result-item">Walls Hit: <strong id="finalHits">0</strong></div>
      <div class="result-item">Time: <strong id="finalTime">0s</strong></div>
      <div class="result-item">Coins Earned: <strong style="color:#10b981" id="coinsEarned">+0</strong></div>
      <div class="result-item">Penalties: <strong style="color:#ef4444" id="coinsLost">-0</strong></div>
      <div class="result-item" style="font-size:18px;margin-top:8px;">Net: <strong id="netCoins">0</strong></div>
      <div class="result-item">New Balance: <strong id="newBalance">0</strong></div>
    </div>
    <div>
      <button onclick="location.reload()">Play Again</button>
      <button onclick="location.href='/'">Dashboard</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GRID_SIZE = 20;
    const CELL_SIZE = canvas.width / GRID_SIZE;
    const TICK_RATE = 150;
    const WALL_SPAWN_INTERVAL = 3000;

    const startingBalance = {{ profile.coins|floatformat:0 }};

    let gameState = {
      player: { x: 10, y: 10, direction: 'UP', alive: true },
      walls: [],
      countdownWalls: [],
      wallsSurvived: 0,
      wallsHit: 0,
      currentScore: 0,
      startTime: Date.now(),
      lastWallSpawn: Date.now(),
      gameOver: false
    };

    let currentDirection = 'UP';
    let nextDirection = 'UP';
    let gameStarted = false;
    let gameLoopInterval = null;
    let wallSpawnInterval = null;
    let countdownInterval = null;
    let botImage = null;

    // Create default bot skin (arrow pointing UP)
    function createBotImage() {
      const size = 64;
      const img = document.createElement('canvas');
      img.width = size;
      img.height = size;
      const c = img.getContext('2d');
      
      // Draw arrow pointing UP
      c.fillStyle = '#5b7bff';
      c.beginPath();
      c.moveTo(size/2, size*0.2);
      c.lineTo(size*0.8, size*0.5);
      c.lineTo(size*0.6, size*0.5);
      c.lineTo(size*0.6, size*0.8);
      c.lineTo(size*0.4, size*0.8);
      c.lineTo(size*0.4, size*0.5);
      c.lineTo(size*0.2, size*0.5);
      c.closePath();
      c.fill();
      
      // Add outline
      c.strokeStyle = '#fff';
      c.lineWidth = 2;
      c.stroke();
      
      return img;
    }

    document.addEventListener('keydown', (e) => {
      if (!gameStarted || gameState.gameOver) return;

      if (e.key === 'Escape') {
        endGame();
        return;
      }

      const key = e.key.toUpperCase();
      if (key === 'W' || key === 'ARROWUP') nextDirection = 'UP';
      else if (key === 'S' || key === 'ARROWDOWN') nextDirection = 'DOWN';
      else if (key === 'A' || key === 'ARROWLEFT') nextDirection = 'LEFT';
      else if (key === 'D' || key === 'ARROWRIGHT') nextDirection = 'RIGHT';
    });

    function initGame() {
      gameState.player = { x: 10, y: 10, direction: 'UP', alive: true };
      gameState.walls = [];
      gameState.countdownWalls = [];
      gameState.wallsSurvived = 0;
      gameState.wallsHit = 0;
      gameState.currentScore = 0;
      gameState.startTime = Date.now();
      gameState.lastWallSpawn = Date.now();
      gameState.gameOver = false;
      
      currentDirection = 'UP';
      nextDirection = 'UP';
      
      botImage = createBotImage();
      
      startGameLoop();
    }

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      gameLoopInterval = setInterval(() => {
        if (!gameState.gameOver) {
          updateGame();
          render();
          updateHUD();
        }
      }, TICK_RATE);
      
      wallSpawnInterval = setInterval(() => {
        if (!gameState.gameOver) {
          spawnWall();
        }
      }, WALL_SPAWN_INTERVAL);
      
      countdownInterval = setInterval(() => {
        if (!gameState.gameOver) {
          updateCountdownWalls();
        }
      }, 1000);
    }

    function updateGame() {
      currentDirection = nextDirection;
      gameState.player.direction = currentDirection;
      
      let newX = gameState.player.x;
      let newY = gameState.player.y;
      
      if (currentDirection === 'UP') newY--;
      else if (currentDirection === 'DOWN') newY++;
      else if (currentDirection === 'LEFT') newX--;
      else if (currentDirection === 'RIGHT') newX++;
      
      // Check edge collision - lose 1 point
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
        gameState.wallsHit++;
        gameState.currentScore--;
        
        // Check if reached -50
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return; // Don't move, just bounce
      }
      
      // Check wall collision - lose 1 point
      const hitWall = gameState.walls.some(w => w.x === newX && w.y === newY);
      if (hitWall) {
        gameState.wallsHit++;
        gameState.currentScore--;
        
        // Check if reached -50
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return; // Don't move, just bounce
      }
      
      // Update position only if valid
      gameState.player.x = newX;
      gameState.player.y = newY;
    }

    function spawnWall() {
      let x, y;
      let attempts = 0;
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        attempts++;
      } while (
        attempts < 100 &&
        (isOccupied(x, y) || (x === gameState.player.x && y === gameState.player.y))
      );
      
      if (attempts < 100) {
        gameState.countdownWalls.push({ x, y, secondsLeft: 3 });
      }
    }

    function updateCountdownWalls() {
      gameState.countdownWalls = gameState.countdownWalls.filter(w => {
        w.secondsLeft--;
        if (w.secondsLeft <= 0) {
          gameState.walls.push({ x: w.x, y: w.y });
          gameState.wallsSurvived++;
          gameState.currentScore++; // Gain 1 point per wall survived
          return false;
        }
        return true;
      });
    }

    function isOccupied(x, y) {
      return gameState.walls.some(w => w.x === x && w.y === y) ||
             gameState.countdownWalls.some(w => w.x === x && w.y === y);
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = '#121428';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = '#23264a';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }
      
      // Draw edge indicators (so players know edges are deadly)
      ctx.fillStyle = '#ef4444';
      ctx.globalAlpha = 0.2;
      ctx.fillRect(0, 0, canvas.width, 4);
      ctx.fillRect(0, canvas.height - 4, canvas.width, 4);
      ctx.fillRect(0, 0, 4, canvas.height);
      ctx.fillRect(canvas.width - 4, 0, 4, canvas.height);
      ctx.globalAlpha = 1.0;
      
      // Draw walls
      ctx.fillStyle = '#ef4444';
      gameState.walls.forEach(w => {
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
      });
      
      // Draw countdown walls
      gameState.countdownWalls.forEach(w => {
        const alpha = 0.3 + (0.7 * (3 - w.secondsLeft) / 3);
        ctx.fillStyle = `rgba(239, 68, 68, ${alpha})`;
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(w.secondsLeft, (w.x + 0.5) * CELL_SIZE, (w.y + 0.5) * CELL_SIZE);
      });
      
      // Draw player with rotation based on direction
      const px = gameState.player.x * CELL_SIZE + CELL_SIZE / 2;
      const py = gameState.player.y * CELL_SIZE + CELL_SIZE / 2;
      
      ctx.save();
      ctx.translate(px, py);
      
      // Rotate image based on direction
      let angle = 0;
      if (currentDirection === 'DOWN') angle = Math.PI;
      else if (currentDirection === 'LEFT') angle = -Math.PI / 2;
      else if (currentDirection === 'RIGHT') angle = Math.PI / 2;
      
      ctx.rotate(angle);
      
      // Draw bot image (centered and rotated)
      const drawSize = CELL_SIZE - 8;
      ctx.drawImage(botImage, -drawSize/2, -drawSize/2, drawSize, drawSize);
      
      ctx.restore();
    }

    function updateHUD() {
      document.getElementById('wallsSurvived').textContent = gameState.wallsSurvived;
      document.getElementById('wallsHit').textContent = gameState.wallsHit;
      
      const scoreEl = document.getElementById('currentScore');
      scoreEl.textContent = gameState.currentScore;
      scoreEl.className = 'stat-value ' + (gameState.currentScore >= 0 ? 'score-positive' : 'score-negative');
      
      const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('time').textContent = elapsed + 's';
    }

    async function endGame() {
      if (gameState.gameOver) return;
      gameState.gameOver = true;
      
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      const survivalTime = Math.floor((Date.now() - gameState.startTime) / 1000);
      
      try {
        const response = await fetch('/matches/save-solo-run/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            wallsSurvived: gameState.wallsSurvived,
            wallsHit: gameState.wallsHit,
            survivalTime: survivalTime,
            finalGridState: {
              playerPos: gameState.player,
              walls: gameState.walls,
              countdownWalls: gameState.countdownWalls
            }
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showGameOver(data);
        } else {
          alert('Error saving game: ' + data.error);
        }
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function showGameOver(data) {
      document.getElementById('finalScore').textContent = gameState.currentScore;
      document.getElementById('finalWalls').textContent = data.wallsSurvived;
      document.getElementById('finalHits').textContent = gameState.wallsHit;
      document.getElementById('finalTime').textContent = 
        Math.floor((Date.now() - gameState.startTime) / 1000) + 's';
      document.getElementById('coinsEarned').textContent = '+' + data.coinsEarned.toFixed(0);
      document.getElementById('coinsLost').textContent = '-' + data.coinsLost.toFixed(0);
      
      const net = data.netCoins;
      const netEl = document.getElementById('netCoins');
      netEl.textContent = (net >= 0 ? '+' : '') + net.toFixed(0);
      netEl.style.color = net >= 0 ? '#10b981' : '#ef4444';
      
      document.getElementById('newBalance').textContent = data.newBalance.toFixed(0);
      
      document.getElementById('gameOver').style.display = 'block';
    }

    function getCookie(name) {
      let value = '; ' + document.cookie;
      let parts = value.split('; ' + name + '=');
      if (parts.length === 2) return parts.pop().split(';').shift();
    }

    function startGame() {
      console.log('Starting game...');
      gameStarted = true;
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'block';
      document.getElementById('controls').style.display = 'block';
      document.getElementById('hud').style.display = 'block';
      initGame();
    }
  </script>
</body>
</html>