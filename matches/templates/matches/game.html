<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Solo Mode - Dash Arena</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0;}
    body{font-family:system-ui,sans-serif;background:#0d0f1a;color:#e6e6e6;overflow:hidden;}
    #gameContainer{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;padding:20px;}
    #gameCanvas{border:2px solid #2a2f6b;background:#121428;box-shadow:0 4px 20px rgba(0,0,0,0.5);}
    #hud{position:absolute;top:20px;left:20px;background:rgba(18,20,40,0.9);padding:16px;border-radius:8px;border:1px solid #2a2f6b;min-width:200px;}
    .stat{margin-bottom:8px;font-size:14px;}
    .stat-label{color:#9ca3af;margin-right:8px;}
    .stat-value{color:#fff;font-weight:600;}
    #gameOver{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(18,20,40,0.98);padding:40px;border-radius:12px;border:2px solid #2a2f6b;text-align:center;min-width:400px;}
    #gameOver h2{margin-bottom:16px;font-size:28px;color:#5b7bff;}
    #gameOver .result{margin-bottom:24px;}
    #gameOver .result-item{margin:8px 0;font-size:16px;}
    #gameOver button{background:#2a2f6b;color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:15px;margin:0 8px;}
    #gameOver button:hover{background:#3940a3;}
    .controls{margin-top:16px;color:#9ca3af;font-size:13px;}
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="600" height="600" style="display:none;"></canvas>
    <div id="startScreen" style="text-align:center;">
      <h1 style="font-size:48px;margin-bottom:16px;color:#5b7bff;">Solo Mode</h1>
      <p style="color:#9ca3af;margin-bottom:32px;font-size:18px;">Use Arrow Keys or WASD to move ‚Ä¢ Survive as long as possible!</p>
      <button onclick="startGame()" style="background:#2a2f6b;color:#fff;border:none;padding:16px 48px;border-radius:8px;cursor:pointer;font-size:20px;font-weight:600;margin-top:16px;">Start Game</button>
      <div style="margin-top:32px;color:#9ca3af;font-size:14px;">
        <div style="margin:8px 0;">üéØ 10 walls: +5 coins</div>
        <div style="margin:8px 0;">üéØ 20 walls: +15 coins</div>
        <div style="margin:8px 0;">üéØ 30 walls: +30 coins</div>
        <div style="margin:8px 0;">üéØ 40 walls: +50 coins</div>
        <div style="margin:8px 0;">üéØ 50+ walls: +75 coins</div>
        <div style="margin:16px 0;color:#ef4444;">‚ö†Ô∏è Wall hit: -3 coins</div>
      </div>
    </div>
    <div class="controls" style="display:none;" id="controls">Arrow Keys or WASD to change direction ‚Ä¢ ESC to quit</div>
  </div>

  <div id="hud" style="display:none;">
    <div class="stat">
      <span class="stat-label">Coins:</span>
      <span class="stat-value" id="coins">{{ profile.coins|floatformat:0 }}</span>
    </div>
    <div class="stat">
      <span class="stat-label">Walls Survived:</span>
      <span class="stat-value" id="wallsSurvived">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Walls Hit:</span>
      <span class="stat-value" id="wallsHit">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Time:</span>
      <span class="stat-value" id="time">0s</span>
    </div>
    <div class="stat">
      <span class="stat-label">High Score:</span>
      <span class="stat-value" id="highScore">{{ profile.soloHighScore }}</span>
    </div>
  </div>

  <div id="gameOver">
    <h2>Game Over</h2>
    <div class="result">
      <div class="result-item">Walls Survived: <strong id="finalWalls">0</strong></div>
      <div class="result-item">Walls Hit: <strong id="finalHits">0</strong></div>
      <div class="result-item">Time: <strong id="finalTime">0s</strong></div>
      <div class="result-item">Coins Earned: <strong style="color:#10b981" id="coinsEarned">+0</strong></div>
      <div class="result-item">Penalties: <strong style="color:#ef4444" id="coinsLost">-0</strong></div>
      <div class="result-item" style="font-size:18px;margin-top:8px;">Net: <strong id="netCoins">0</strong></div>
      <div class="result-item">New Balance: <strong id="newBalance">0</strong></div>
    </div>
    <div>
      <button onclick="location.reload()">Play Again</button>
      <button onclick="location.href='/'">Dashboard</button>
    </div>
  </div>

  <script>
    // Game.js - Inline version
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GRID_SIZE = 20;
    const CELL_SIZE = canvas.width / GRID_SIZE;
    const TICK_RATE = 150;
    const WALL_SPAWN_INTERVAL = 3000;

    let gameState = {
      player: { x: 10, y: 10, direction: 'UP', alive: true },
      walls: [],
      countdownWalls: [],
      wallsSurvived: 0,
      wallsHit: 0,
      startTime: Date.now(),
      lastWallSpawn: Date.now(),
      gameOver: false
    };

    let currentDirection = 'UP';
    let nextDirection = 'UP';
    let gameStarted = false;
    let gameLoopInterval = null;
    let wallSpawnInterval = null;
    let countdownInterval = null;

    document.addEventListener('keydown', (e) => {
      if (!gameStarted || gameState.gameOver) return;

      if (e.key === 'Escape') {
        endGame();
        return;
      }

      const key = e.key.toUpperCase();
      if (key === 'W' || key === 'ARROWUP') nextDirection = 'UP';
      else if (key === 'S' || key === 'ARROWDOWN') nextDirection = 'DOWN';
      else if (key === 'A' || key === 'ARROWLEFT') nextDirection = 'LEFT';
      else if (key === 'D' || key === 'ARROWRIGHT') nextDirection = 'RIGHT';
    });

    function initGame() {
      gameState.player = { x: 10, y: 10, direction: 'UP', alive: true };
      gameState.walls = [];
      gameState.countdownWalls = [];
      gameState.wallsSurvived = 0;
      gameState.wallsHit = 0;
      gameState.startTime = Date.now();
      gameState.lastWallSpawn = Date.now();
      gameState.gameOver = false;
      
      currentDirection = 'UP';
      nextDirection = 'UP';
      
      startGameLoop();
    }

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      gameLoopInterval = setInterval(() => {
        if (!gameState.gameOver) {
          updateGame();
          render();
          updateHUD();
        }
      }, TICK_RATE);
      
      wallSpawnInterval = setInterval(() => {
        if (!gameState.gameOver) {
          spawnWall();
        }
      }, WALL_SPAWN_INTERVAL);
      
      countdownInterval = setInterval(() => {
        if (!gameState.gameOver) {
          updateCountdownWalls();
        }
      }, 1000);
    }

    function updateGame() {
      currentDirection = nextDirection;
      gameState.player.direction = currentDirection;
      
      let newX = gameState.player.x;
      let newY = gameState.player.y;
      
      if (currentDirection === 'UP') newY--;
      else if (currentDirection === 'DOWN') newY++;
      else if (currentDirection === 'LEFT') newX--;
      else if (currentDirection === 'RIGHT') newX++;
      
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
        endGame();
        return;
      }
      
      const hitWall = gameState.walls.some(w => w.x === newX && w.y === newY);
      if (hitWall) {
        gameState.wallsHit++;
      }
      
      gameState.player.x = newX;
      gameState.player.y = newY;
    }

    function spawnWall() {
      let x, y;
      let attempts = 0;
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        attempts++;
      } while (
        attempts < 100 &&
        (isOccupied(x, y) || (x === gameState.player.x && y === gameState.player.y))
      );
      
      if (attempts < 100) {
        gameState.countdownWalls.push({ x, y, secondsLeft: 3 });
      }
    }

    function updateCountdownWalls() {
      gameState.countdownWalls = gameState.countdownWalls.filter(w => {
        w.secondsLeft--;
        if (w.secondsLeft <= 0) {
          gameState.walls.push({ x: w.x, y: w.y });
          gameState.wallsSurvived++;
          return false;
        }
        return true;
      });
    }

    function isOccupied(x, y) {
      return gameState.walls.some(w => w.x === x && w.y === y) ||
             gameState.countdownWalls.some(w => w.x === x && w.y === y);
    }

    function render() {
      ctx.fillStyle = '#121428';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = '#23264a';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }
      
      ctx.fillStyle = '#ef4444';
      gameState.walls.forEach(w => {
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
      });
      
      gameState.countdownWalls.forEach(w => {
        const alpha = 0.3 + (0.7 * (3 - w.secondsLeft) / 3);
        ctx.fillStyle = `rgba(239, 68, 68, ${alpha})`;
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(w.secondsLeft, (w.x + 0.5) * CELL_SIZE, (w.y + 0.5) * CELL_SIZE);
      });
      
      ctx.fillStyle = '#5b7bff';
      ctx.fillRect(
        gameState.player.x * CELL_SIZE + 4,
        gameState.player.y * CELL_SIZE + 4,
        CELL_SIZE - 8,
        CELL_SIZE - 8
      );
      
      ctx.fillStyle = '#fff';
      const px = gameState.player.x * CELL_SIZE + CELL_SIZE / 2;
      const py = gameState.player.y * CELL_SIZE + CELL_SIZE / 2;
      ctx.beginPath();
      if (currentDirection === 'UP') {
        ctx.moveTo(px, py - 8);
        ctx.lineTo(px - 4, py - 2);
        ctx.lineTo(px + 4, py - 2);
      } else if (currentDirection === 'DOWN') {
        ctx.moveTo(px, py + 8);
        ctx.lineTo(px - 4, py + 2);
        ctx.lineTo(px + 4, py + 2);
      } else if (currentDirection === 'LEFT') {
        ctx.moveTo(px - 8, py);
        ctx.lineTo(px - 2, py - 4);
        ctx.lineTo(px - 2, py + 4);
      } else if (currentDirection === 'RIGHT') {
        ctx.moveTo(px + 8, py);
        ctx.lineTo(px + 2, py - 4);
        ctx.lineTo(px + 2, py + 4);
      }
      ctx.fill();
    }

    function updateHUD() {
      document.getElementById('wallsSurvived').textContent = gameState.wallsSurvived;
      document.getElementById('wallsHit').textContent = gameState.wallsHit;
      
      const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('time').textContent = elapsed + 's';
    }

    async function endGame() {
      if (gameState.gameOver) return;
      gameState.gameOver = true;
      
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      const survivalTime = Math.floor((Date.now() - gameState.startTime) / 1000);
      
      try {
        const response = await fetch('/matches/save-solo-run/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            wallsSurvived: gameState.wallsSurvived,
            wallsHit: gameState.wallsHit,
            survivalTime: survivalTime,
            finalGridState: {
              playerPos: gameState.player,
              walls: gameState.walls,
              countdownWalls: gameState.countdownWalls
            }
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showGameOver(data);
        } else {
          alert('Error saving game: ' + data.error);
        }
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function showGameOver(data) {
      document.getElementById('finalWalls').textContent = data.wallsSurvived;
      document.getElementById('finalHits').textContent = gameState.wallsHit;
      document.getElementById('finalTime').textContent = 
        Math.floor((Date.now() - gameState.startTime) / 1000) + 's';
      document.getElementById('coinsEarned').textContent = '+' + data.coinsEarned.toFixed(0);
      document.getElementById('coinsLost').textContent = '-' + data.coinsLost.toFixed(0);
      
      const net = data.netCoins;
      const netEl = document.getElementById('netCoins');
      netEl.textContent = (net >= 0 ? '+' : '') + net.toFixed(0);
      netEl.style.color = net >= 0 ? '#10b981' : '#ef4444';
      
      document.getElementById('newBalance').textContent = data.newBalance.toFixed(0);
      
      document.getElementById('gameOver').style.display = 'block';
    }

    function getCookie(name) {
      let value = '; ' + document.cookie;
      let parts = value.split('; ' + name + '=');
      if (parts.length === 2) return parts.pop().split(';').shift();
    }

    function startGame() {
      console.log('Starting game...');
      gameStarted = true;
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'block';
      document.getElementById('controls').style.display = 'block';
      document.getElementById('hud').style.display = 'block';
      initGame();
    }
  </script>
</body>
</html>