<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Solo Mode - Dash Arena</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, sans-serif;
      background: #0d0f1a;
      color: #e6e6e6;
      overflow: hidden;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 20px;
    }
    #gameCanvas {
      border: 2px solid #2a2f6b;
      background: #121428;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(18,20,40,0.9);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f6b;
      min-width: 200px;
    }
    .stat {
      margin-bottom: 8px;
      font-size: 14px;
    }
    .stat-label {
      color: #9ca3af;
      margin-right: 8px;
    }
    .stat-value {
      color: #fff;
      font-weight: 600;
    }
    .score-positive {
      color: #10b981;
    }
    .score-negative {
      color: #ef4444;
    }
    #gameOver {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(18,20,40,0.98);
      padding: 40px;
      border-radius: 12px;
      border: 2px solid #2a2f6b;
      text-align: center;
      min-width: 400px;
      z-index: 1000;
    }
    #gameOver h2 {
      margin-bottom: 16px;
      font-size: 28px;
      color: #5b7bff;
    }
    #gameOver .result {
      margin-bottom: 24px;
    }
    #gameOver .result-item {
      margin: 8px 0;
      font-size: 16px;
    }
    #gameOver button {
      background: #2a2f6b;
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 15px;
      margin: 0 8px;
    }
    #gameOver button:hover {
      background: #3940a3;
    }
    .controls {
      margin-top: 16px;
      color: #9ca3af;
      font-size: 13px;
    }
    #mobile-controls {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, 70px);
      grid-template-rows: repeat(3, 70px);
      gap: 8px;
      justify-content: center;
    }
    #mobile-controls button {
      font-size: 24px;
      padding: 0;
      border-radius: 10px;
      border: 2px solid #2a2f6b;
      background: rgba(42, 47, 107, 0.8);
      color: white;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #mobile-controls button:active {
      background: rgba(57, 64, 163, 0.9);
    }
    .btn-up {
      grid-column: 2;
      grid-row: 1;
    }
    .btn-left {
      grid-column: 1;
      grid-row: 2;
    }
    .btn-down {
      grid-column: 2;
      grid-row: 2;
    }
    .btn-right {
      grid-column: 3;
      grid-row: 2;
    }
    .btn-escape {
      grid-column: 2;
      grid-row: 3;
      font-size: 14px;
      background: rgba(239, 68, 68, 0.8);
    }
    .btn-escape:active {
      background: rgba(239, 68, 68, 1);
    }
    @media (max-width: 768px) {
      #hud {
        top: 10px;
        left: 10px;
        padding: 12px;
        min-width: 150px;
        font-size: 12px;
      }
      .stat {
        margin-bottom: 6px;
        font-size: 12px;
      }
      #gameOver {
        min-width: 90%;
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="600" height="600" style="display:none;"></canvas>
    
    <div id="mobile-controls" style="display:none;">
      <button class="btn-up" onmousedown="pressKey('ArrowUp')" onmouseup="releaseKey('ArrowUp')" ontouchstart="pressKey('ArrowUp')" ontouchend="releaseKey('ArrowUp')">â–²</button>
      <button class="btn-left" onmousedown="pressKey('ArrowLeft')" onmouseup="releaseKey('ArrowLeft')" ontouchstart="pressKey('ArrowLeft')" ontouchend="releaseKey('ArrowLeft')">â—€</button>
      <button class="btn-down" onmousedown="pressKey('ArrowDown')" onmouseup="releaseKey('ArrowDown')" ontouchstart="pressKey('ArrowDown')" ontouchend="releaseKey('ArrowDown')">â–¼</button>
      <button class="btn-right" onmousedown="pressKey('ArrowRight')" onmouseup="releaseKey('ArrowRight')" ontouchstart="pressKey('ArrowRight')" ontouchend="releaseKey('ArrowRight')">â–¶</button>
      <button class="btn-escape" onclick="endGame()">ESC</button>
    </div>

    <div id="startScreen" style="text-align:center;">
      <h1 style="font-size:48px;margin-bottom:16px;color:#5b7bff;">Solo Mode</h1>
      <p style="color:#9ca3af;margin-bottom:32px;font-size:18px;">Use Arrow Keys or WASD to move</p>
      <button onclick="startGame()" style="background:#2a2f6b;color:#fff;border:none;padding:16px 48px;border-radius:8px;cursor:pointer;font-size:20px;font-weight:600;margin-top:16px;">Start Game</button>
      <div style="margin-top:32px;color:#9ca3af;font-size:14px;">
        <div style="margin:8px 0;color:#10b981;">Each wall spawned: +1 point</div>
        <div style="margin:8px 0;color:#ef4444;">Each wall/edge hit: -1 point</div>
        <div style="margin:16px 0;color:#ef4444;font-weight:600;">Game Over at -50 points</div>
        <div style="margin:16px 0;color:#fbbf24;">Press ESC anytime to quit and save your score</div>
      </div>
    </div>
    <div class="controls" style="display:none;" id="controls">Arrow Keys or WASD to change direction</div>
  </div>

  <div id="hud" style="display:none;">
    <div class="stat">
      <span class="stat-label">Current Score:</span>
      <span class="stat-value" id="currentScore">0</span>
    </div>

    <!-- Sound toggle -->
    <button
      onclick="toggleSound()"
      id="soundBtn"
      style="
        width:100%;
        margin:8px 0;
        padding:8px;
        background:#2a2f6b;
        border:none;
        border-radius:6px;
        color:#fff;
        cursor:pointer;
        font-size:13px;
      "
    >
      ðŸ”Š Sound ON
    </button>

    <div class="stat">
      <span class="stat-label">Walls Survived:</span>
      <span class="stat-value" id="wallsSurvived">0</span>
    </div>

    <div class="stat">
      <span class="stat-label">Walls Hit:</span>
      <span class="stat-value" id="wallsHit">0</span>
    </div>

    <div class="stat">
      <span class="stat-label">Time:</span>
      <span class="stat-value" id="time">0s</span>
    </div>
  </div>

  <div id="gameOver">
    <h2>Game Over</h2>
    <div class="result">
      <div class="result-item">Final Score: <strong id="finalScore">0</strong></div>
      <div class="result-item">Walls Survived: <strong id="finalWalls">0</strong></div>
      <div class="result-item">Walls Hit: <strong id="finalHits">0</strong></div>
      <div class="result-item">Time: <strong id="finalTime">0s</strong></div>
    </div>
    <div>
      <button onclick="location.reload()">Play Again</button>
      <button onclick="location.href='/'">Dashboard</button>
    </div>
  </div>

  <script>
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');

    var GRID_SIZE = 20;
    var CELL_SIZE = 0;
    var TICK_RATE = 150;
    var WALL_SPAWN_INTERVAL = 3000;

    var gameState = {
      player: null,
      walls: [],
      countdownWalls: [],
      wallsSurvived: 0,
      wallsHit: 0,
      currentScore: 0,
      startTime: 0,
      gameOver: false
    };

    var currentDirection = 'UP';
    var nextDirection = 'UP';
    var gameStarted = false;
    var gameLoopInterval = null;
    var wallSpawnInterval = null;
    var countdownInterval = null;
    var botImage = null;

    function adjustCanvasSize() {
      var maxWidth = window.innerWidth - 40;
      var maxHeight = window.innerHeight - 300;
      var size = Math.min(600, maxWidth, maxHeight);
      
      canvas.width = size;
      canvas.height = size;
      
      if (size < 400) {
        GRID_SIZE = 15;
      } else if (size < 500) {
        GRID_SIZE = 18;
      } else {
        GRID_SIZE = 20;
      }
      
      CELL_SIZE = canvas.width / GRID_SIZE;
    }

    function createBotImage() {
      var size = 64;
      var img = document.createElement('canvas');
      img.width = size;
      img.height = size;
      var c = img.getContext('2d');
      
      c.fillStyle = '#5b7bff';
      c.beginPath();
      c.moveTo(size/2, size*0.2);
      c.lineTo(size*0.8, size*0.5);
      c.lineTo(size*0.6, size*0.5);
      c.lineTo(size*0.6, size*0.8);
      c.lineTo(size*0.4, size*0.8);
      c.lineTo(size*0.4, size*0.5);
      c.lineTo(size*0.2, size*0.5);
      c.closePath();
      c.fill();
      
      c.strokeStyle = '#fff';
      c.lineWidth = 2;
      c.stroke();
      
      return img;
    }

    document.addEventListener('keydown', function(e) {
      if (!gameStarted || gameState.gameOver) return;

      if (e.key === 'Escape') {
        endGame();
        return;
      }

      var key = e.key.toUpperCase();
      if (key === 'W' || key === 'ARROWUP') nextDirection = 'UP';
      else if (key === 'S' || key === 'ARROWDOWN') nextDirection = 'DOWN';
      else if (key === 'A' || key === 'ARROWLEFT') nextDirection = 'LEFT';
      else if (key === 'D' || key === 'ARROWRIGHT') nextDirection = 'RIGHT';
    });

    function initGame() {
      adjustCanvasSize();
      
      var centerX = Math.floor(GRID_SIZE / 2);
      var centerY = Math.floor(GRID_SIZE / 2);
      
      gameState.player = {
        x: centerX,
        y: centerY,
        direction: 'UP',
        alive: true
      };
      gameState.walls = [];
      gameState.countdownWalls = [];
      gameState.wallsSurvived = 0;
      gameState.wallsHit = 0;
      gameState.currentScore = 0;
      gameState.startTime = Date.now();
      gameState.gameOver = false;
      
      currentDirection = 'UP';
      nextDirection = 'UP';
      
      botImage = createBotImage();
      
      startGameLoop();
    }

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      gameLoopInterval = setInterval(function() {
        if (!gameState.gameOver) {
          updateGame();
          render();
          updateHUD();
        }
      }, TICK_RATE);
      
      wallSpawnInterval = setInterval(function() {
        if (!gameState.gameOver) {
          spawnWall();
        }
      }, WALL_SPAWN_INTERVAL);
      
      countdownInterval = setInterval(function() {
        if (!gameState.gameOver) {
          updateCountdownWalls();
        }
      }, 1000);
    }

    function updateGame() {
      currentDirection = nextDirection;
      gameState.player.direction = currentDirection;
      
      var newX = gameState.player.x;
      var newY = gameState.player.y;
      
      if (currentDirection === 'UP') newY--;
      else if (currentDirection === 'DOWN') newY++;
      else if (currentDirection === 'LEFT') newX--;
      else if (currentDirection === 'RIGHT') newX++;
      
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
        gameState.wallsHit++;
        gameState.currentScore--;
        
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return;
      }
      
      var hitWall = gameState.walls.some(function(w) {
        return w.x === newX && w.y === newY;
      });
      
      if (hitWall) {
        gameState.wallsHit++;
        gameState.currentScore--;
        
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return;
      }
      
      gameState.player.x = newX;
      gameState.player.y = newY;
    }

    function spawnWall() {
      var x, y;
      var attempts = 0;
      
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        attempts++;
      } while (
        attempts < 100 &&
        (isOccupied(x, y) || (x === gameState.player.x && y === gameState.player.y))
      );
      
      if (attempts < 100) {
        gameState.countdownWalls.push({
          x: x,
          y: y,
          secondsLeft: 3
        });
      }
    }

    function updateCountdownWalls() {
      gameState.countdownWalls = gameState.countdownWalls.filter(function(w) {
        w.secondsLeft--;
        if (w.secondsLeft <= 0) {
          gameState.walls.push({
            x: w.x,
            y: w.y
          });
          gameState.wallsSurvived++;
          gameState.currentScore++;
          return false;
        }
        return true;
      });
    }

    function isOccupied(x, y) {
      var wallCheck = gameState.walls.some(function(w) {
        return w.x === x && w.y === y;
      });
      var countdownCheck = gameState.countdownWalls.some(function(w) {
        return w.x === x && w.y === y;
      });
      return wallCheck || countdownCheck;
    }

    function render() {
      ctx.fillStyle = '#121428';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = '#23264a';
      ctx.lineWidth = 1;
      for (var i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }
      
      ctx.fillStyle = '#ef4444';
      ctx.globalAlpha = 0.2;
      ctx.fillRect(0, 0, canvas.width, 4);
      ctx.fillRect(0, canvas.height - 4, canvas.width, 4);
      ctx.fillRect(0, 0, 4, canvas.height);
      ctx.fillRect(canvas.width - 4, 0, 4, canvas.height);
      ctx.globalAlpha = 1.0;
      
      ctx.fillStyle = '#ef4444';
      gameState.walls.forEach(function(w) {
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
      });
      
      gameState.countdownWalls.forEach(function(w) {
        var alpha = 0.3 + (0.7 * (3 - w.secondsLeft) / 3);
        ctx.fillStyle = 'rgba(239, 68, 68, ' + alpha + ')';
        ctx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        
        ctx.fillStyle = '#fff';
        var fontSize = Math.max(12, CELL_SIZE * 0.5);
        ctx.font = 'bold ' + fontSize + 'px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(w.secondsLeft, (w.x + 0.5) * CELL_SIZE, (w.y + 0.5) * CELL_SIZE);
      });
      
      var px = gameState.player.x * CELL_SIZE + CELL_SIZE / 2;
      var py = gameState.player.y * CELL_SIZE + CELL_SIZE / 2;
      
      ctx.save();
      ctx.translate(px, py);
      
      var angle = 0;
      if (currentDirection === 'DOWN') angle = Math.PI;
      else if (currentDirection === 'LEFT') angle = -Math.PI / 2;
      else if (currentDirection === 'RIGHT') angle = Math.PI / 2;
      
      ctx.rotate(angle);
      
      var drawSize = CELL_SIZE - 8;
      ctx.drawImage(botImage, -drawSize/2, -drawSize/2, drawSize, drawSize);
      
      ctx.restore();
    }

    function updateHUD() {
      document.getElementById('wallsSurvived').textContent = gameState.wallsSurvived;
      document.getElementById('wallsHit').textContent = gameState.wallsHit;
      
      var scoreEl = document.getElementById('currentScore');
      scoreEl.textContent = gameState.currentScore;
      scoreEl.className = 'stat-value ' + (gameState.currentScore >= 0 ? 'score-positive' : 'score-negative');
      
      var elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('time').textContent = elapsed + 's';
    }

    function endGame() {
      if (gameState.gameOver) return;
      gameState.gameOver = true;
      
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      if (wallSpawnInterval) clearInterval(wallSpawnInterval);
      if (countdownInterval) clearInterval(countdownInterval);
      
      showGameOver();
    }

    function showGameOver() {
      document.getElementById('finalScore').textContent = gameState.currentScore;
      document.getElementById('finalWalls').textContent = gameState.wallsSurvived;
      document.getElementById('finalHits').textContent = gameState.wallsHit;
      var elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('finalTime').textContent = elapsed + 's';
      
      document.getElementById('gameOver').style.display = 'block';
    }

    function startGame() {
      gameStarted = true;
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'block';
      document.getElementById('controls').style.display = 'block';
      document.getElementById('hud').style.display = 'block';
      document.getElementById('mobile-controls').style.display = 'grid';
      initGame();
    }

    function pressKey(key) {
      document.dispatchEvent(new KeyboardEvent('keydown', { key: key }));
    }

    function releaseKey(key) {
      document.dispatchEvent(new KeyboardEvent('keyup', { key: key }));
    }

    window.addEventListener('resize', function() {
      if (gameStarted && !gameState.gameOver) {
        adjustCanvasSize();
        render();
      }
    });


    // 1. ADD GAMEAUDIO CLASS (same as multiplayer - paste entire class here)
    class GameAudio {
      constructor() {
        this.audioContext = null;
        this.enabled = true;
      }
      
      init() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }
      
      playMove() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 400;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.05);
      }
      
      playHit() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 150;
        oscillator.type = 'sawtooth';
        
        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.15);
      }
      
      playScore() {
        if (!this.enabled) return;
        this.init();
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.2);
      }
      
      playGameOver() {
        if (!this.enabled) return;
        this.init();
        
        const notes = [392, 330, 262];
        const noteLength = 0.2;
        
        notes.forEach((freq, i) => {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.frequency.value = freq;
          oscillator.type = 'sine';
          
          const startTime = this.audioContext.currentTime + (i * noteLength);
          gainNode.gain.setValueAtTime(0.2, startTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteLength);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + noteLength);
        });
      }
      
      toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
      }
    }

    const gameAudio = new GameAudio();

    // 2. ADD MUTE BUTTON TO HUD
    // In the #hud div, add:
    /*
    <button onclick="toggleSound()" id="soundBtn" style="width:100%;margin:8px 0;padding:8px;background:#2a2f6b;border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:13px;">
      ðŸ”Š Sound ON
    </button>
    */

    // 3. ADD TOGGLE FUNCTION
    function toggleSound() {
      var enabled = gameAudio.toggle();
      document.getElementById('soundBtn').textContent = enabled ? 'ðŸ”Š Sound ON' : 'ðŸ”‡ Sound OFF';
    }

    // 4. UPDATE KEYDOWN HANDLER (add sound to direction changes)
    document.addEventListener('keydown', function(e) {
      if (!gameStarted || gameState.gameOver) return;

      if (e.key === 'Escape') {
        endGame();
        return;
      }

      var key = e.key.toUpperCase();
      if (key === 'W' || key === 'ARROWUP') {
        nextDirection = 'UP';
        gameAudio.playMove(); // ADD THIS
      }
      else if (key === 'S' || key === 'ARROWDOWN') {
        nextDirection = 'DOWN';
        gameAudio.playMove(); // ADD THIS
      }
      else if (key === 'A' || key === 'ARROWLEFT') {
        nextDirection = 'LEFT';
        gameAudio.playMove(); // ADD THIS
      }
      else if (key === 'D' || key === 'ARROWRIGHT') {
        nextDirection = 'RIGHT';
        gameAudio.playMove(); // ADD THIS
      }
    });

    // 5. UPDATE updateGame() TO DETECT HITS
    function updateGame() {
      currentDirection = nextDirection;
      gameState.player.direction = currentDirection;
      
      var newX = gameState.player.x;
      var newY = gameState.player.y;
      
      if (currentDirection === 'UP') newY--;
      else if (currentDirection === 'DOWN') newY++;
      else if (currentDirection === 'LEFT') newX--;
      else if (currentDirection === 'RIGHT') newX++;
      
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
        gameState.wallsHit++;
        gameState.currentScore--;
        gameAudio.playHit(); // ADD THIS
        
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return;
      }
      
      var hitWall = gameState.walls.some(function(w) {
        return w.x === newX && w.y === newY;
      });
      
      if (hitWall) {
        gameState.wallsHit++;
        gameState.currentScore--;
        gameAudio.playHit(); // ADD THIS
        
        if (gameState.currentScore <= -50) {
          endGame();
        }
        return;
      }
      
      gameState.player.x = newX;
      gameState.player.y = newY;
    }

    // 6. UPDATE updateCountdownWalls() TO PLAY SCORE SOUND
    function updateCountdownWalls() {
      gameState.countdownWalls = gameState.countdownWalls.filter(function(w) {
        w.secondsLeft--;
        if (w.secondsLeft <= 0) {
          gameState.walls.push({
            x: w.x,
            y: w.y
          });
          gameState.wallsSurvived++;
          gameState.currentScore++;
          gameAudio.playScore(); // ADD THIS - wall spawned!
          return false;
        }
        return true;
      });
    }

    // 7. UPDATE showGameOver() TO PLAY GAME OVER SOUND
    function showGameOver() {
      gameAudio.playGameOver(); // ADD THIS
      
      document.getElementById('finalScore').textContent = gameState.currentScore;
      document.getElementById('finalWalls').textContent = gameState.wallsSurvived;
      document.getElementById('finalHits').textContent = gameState.wallsHit;
      var elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      document.getElementById('finalTime').textContent = elapsed + 's';
      
      document.getElementById('gameOver').style.display = 'block';
    }
  </script>
</body>
</html>