<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Match - Dash Arena</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, sans-serif;
      background: #0d0f1a;
      color: #e6e6e6;
      overflow: hidden;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 20px;
      position: relative;
    }
    #gameCanvas {
      border: 2px solid #2a2f6b;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      flex-shrink: 0;
    }
    #hud {
      position: static;
      margin-top: 16px;
      background: rgba(18,20,40,0.95);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f6b;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 10;
      pointer-events: auto;
    }
    .stat {
      margin-bottom: 8px;
      font-size: 14px;
    }
    .stat-label {
      color: #9ca3af;
      margin-right: 8px;
    }
    .stat-value {
      color: #fff;
      font-weight: 600;
    }
    .player-item {
      margin: 8px 0;
      padding: 8px;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .player-name {
      font-weight: 600;
    }
    .player-score {
      font-size: 12px;
      font-weight: 600;
    }
    .score-positive {
      color: #10b981;
    }
    .score-negative {
      color: #ef4444;
    }
    .player-dead {
      opacity: 0.5;
      text-decoration: line-through;
    }
    .color-badge {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 3px;
      margin-right: 8px;
      vertical-align: middle;
      border: 1px solid #fff;
    }
    #gameOver {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(18,20,40,0.98);
      padding: 40px;
      border-radius: 12px;
      border: 2px solid #2a2f6b;
      text-align: center;
      min-width: 400px;
      z-index: 1000;
    }
    #gameOver h2 {
      margin-bottom: 16px;
      font-size: 28px;
      color: #5b7bff;
    }
    #gameOver button {
      background: #2a2f6b;
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 15px;
      margin: 8px;
    }
    #gameOver button:hover {
      background: #3940a3;
    }
    #waitingMsg {
      text-align: center;
      font-size: 18px;
      color: #9ca3af;
    }
    #countdownDisplay {
      font-size: 72px;
      font-weight: 700;
      color: #5b7bff;
      margin: 20px 0;
    }
    #mobile-controls {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, 70px);
      grid-template-rows: repeat(2, 70px);
      gap: 8px;
      justify-content: center;
    }
    #mobile-controls button {
      font-size: 24px;
      padding: 0;
      border-radius: 10px;
      border: 2px solid #2a2f6b;
      background: rgba(42, 47, 107, 0.8);
      color: white;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #mobile-controls button:active {
      background: rgba(57, 64, 163, 0.9);
    }
    .btn-up {
      grid-column: 2;
      grid-row: 1;
    }
    .btn-left {
      grid-column: 1;
      grid-row: 2;
    }
    .btn-down {
      grid-column: 2;
      grid-row: 2;
    }
    .btn-right {
      grid-column: 3;
      grid-row: 2;
    }
    @media (max-width: 768px) {
      #gameContainer {
        flex-direction: column;
        padding: 10px;
      }
      #gameCanvas {
        width: 100%;
        height: auto;
        max-width: 500px;
        max-height: 500px;
      }
      #hud {
        position: static;
        margin-top: 12px;
        padding: 10px;
        min-width: auto;
        max-width: 100%;
        max-height: auto;
        font-size: 11px;
        border: 1px solid #2a2f6b;
        border-radius: 8px;
      }
      .stat {
        margin-bottom: 6px;
        font-size: 11px;
      }
      #playerList {
        max-height: 250px;
        overflow-y: auto;
      }
      #gameOver {
        min-width: 90%;
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="waitingMsg">
      <h2 style="color:#5b7bff;margin-bottom:16px;">Match Starting...</h2>
      <p>Connecting to game server...</p>
      <div id="countdownDisplay" style="display:none;"></div>
    </div>
    <canvas id="gameCanvas" width="800" height="800" style="display:none;"></canvas>
    
    <div id="mobile-controls" style="display:none;">
      <button class="btn-up" onmousedown="pressKey('ArrowUp')" onmouseup="releaseKey('ArrowUp')" ontouchstart="pressKey('ArrowUp')" ontouchend="releaseKey('ArrowUp')">‚ñ≤</button>
      <button class="btn-left" onmousedown="pressKey('ArrowLeft')" onmouseup="releaseKey('ArrowLeft')" ontouchstart="pressKey('ArrowLeft')" ontouchend="releaseKey('ArrowLeft')">‚óÄ</button>
      <button class="btn-down" onmousedown="pressKey('ArrowDown')" onmouseup="releaseKey('ArrowDown')" ontouchstart="pressKey('ArrowDown')" ontouchend="releaseKey('ArrowDown')">‚ñº</button>
      <button class="btn-right" onmousedown="pressKey('ArrowRight')" onmouseup="releaseKey('ArrowRight')" ontouchstart="pressKey('ArrowRight')" ontouchend="releaseKey('ArrowRight')">‚ñ∂</button>
    </div>
  </div>

  <div id="hud" style="display:none;">
    <div class="stat">
      <span class="stat-label">Match:</span>
      <span class="stat-value">Multiplayer</span>
    </div>
    <div class="stat" id="yourColorStat" style="display:none;">
      <span class="stat-label">Your Color:</span>
      <span class="color-badge" id="yourColorBadge"></span>
    </div>
    <button onclick="toggleSound()" id="soundBtn" style="width:100%;margin:8px 0;padding:8px;background:#2a2f6b;border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:13px;">
      üîä Sound ON
    </button>
    <hr style="border:1px solid #2a2f6b;margin:12px 0;">
    <div id="playerList"></div>
  </div>

  <div id="gameOver">
    <h2 id="winnerText">Game Over</h2>
    <div id="winnerInfo" style="margin:24px 0;font-size:18px;"></div>
    <div id="finalScores" style="margin:16px 0;font-size:14px;color:#9ca3af;"></div>
    <div>
      <button onclick="location.href='/matches/multiplayer/'">Find Another Match</button>
      <button onclick="location.href='/'">Dashboard</button>
    </div>
  </div>

  <script>
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');

    var gameState = null;
    var socket = null;
    var CELL_SIZE = 0;
    var botImages = {};
    var myPlayerColor = null;
    var isGameStarted = false;

    // Death explosion animation
    var deathFrame = null;
    var deathLocation = null;
    var explosionFrames = 0;
    var killerPlayerId = null;

    function adjustCanvasSize() {
      var maxWidth = window.innerWidth - 40;
      var maxHeight = window.innerHeight - 300;
      var size = Math.min(800, maxWidth, maxHeight);
      
      canvas.width = size;
      canvas.height = size;
    }

    function createBotImage(color) {
      var size = 128; // Doubled from 64 for bigger arrow
      var img = document.createElement('canvas');
      img.width = size;
      img.height = size;
      var c = img.getContext('2d');
      
      // BIGGER chevron arrow - like < symbol
      c.fillStyle = color;
      c.strokeStyle = '#fff';
      c.lineWidth = 4;
      c.lineJoin = 'miter';
      c.lineCap = 'square';
      
      c.beginPath();
      // Arrow pointing UP (will be rotated for other directions)
      c.moveTo(size * 0.5, size * 0.15);  // Top point
      c.lineTo(size * 0.85, size * 0.5);  // Right corner
      c.lineTo(size * 0.65, size * 0.5);  // Right inner
      c.lineTo(size * 0.65, size * 0.85); // Right bottom
      c.lineTo(size * 0.35, size * 0.85); // Left bottom
      c.lineTo(size * 0.35, size * 0.5);  // Left inner
      c.lineTo(size * 0.15, size * 0.5);  // Left corner
      c.closePath();
      c.fill();
      c.stroke();
      
      return img;
    }

    function getBotImage(playerColor) {
      if (!botImages[playerColor]) {
        botImages[playerColor] = createBotImage(playerColor);
      }
      return botImages[playerColor];
    }

    function connectWebSocket() {
      var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      var wsUrl = protocol + '//' + window.location.host + '/ws/match/{{ match.id }}/';
      
      console.log('Attempting WebSocket connection to:', wsUrl);
      socket = new WebSocket(wsUrl);
      
      socket.onopen = function() {
        console.log('Connected to game');
        document.getElementById('waitingMsg').innerHTML = '<h2 style="color:#10b981;">Connected!</h2><p>Waiting for game to start...</p><div id="countdownDisplay" style="display:none;"></div>';
      };
      
      socket.onmessage = function(event) {
        var data = JSON.parse(event.data);
        
        if (data.type === 'playerColor') {
          myPlayerColor = data.playerColor;
          document.getElementById('yourColorStat').style.display = 'block';
          document.getElementById('yourColorBadge').style.backgroundColor = myPlayerColor;
          console.log('Your color:', myPlayerColor);
        } else if (data.type === 'countdown') {
          // Show countdown
          var countdownEl = document.getElementById('countdownDisplay');
          countdownEl.style.display = 'block';
          countdownEl.textContent = data.seconds;
          document.getElementById('waitingMsg').querySelector('p').textContent = 'Game starting in...';
        } else if (data.type === 'gameOver') {
          console.log('üèÅ Game over message received, calling handleGameOver');
          handleGameOver(data);
        } else {
          // Regular game state
          // Detect if we died (game state update)
          var myPlayerId = null;
          if (myPlayerColor) {
            for (var id in data.players) {
              if (data.players[id].playerColor === myPlayerColor) {
                myPlayerId = id;
                break;
              }
            }
          }
          
          if (myPlayerId && gameState && gameState.players && gameState.players[myPlayerId]) {
            var wasMeAlive = gameState.players[myPlayerId].alive;
            var amIAliveNow = data.players[myPlayerId].alive;
            
            // I just died
            if (wasMeAlive && !amIAliveNow && deathFrame === null) {
              deathFrame = 0;
              deathLocation = { x: gameState.players[myPlayerId].x, y: gameState.players[myPlayerId].y };
              explosionFrames = 0;
              
              // Find who killed me
              for (var otherId in data.players) {
                if (otherId !== myPlayerId && data.players[otherId].alive) {
                  // Check if they're at same location or nearby
                  if (data.players[otherId].x === deathLocation.x && data.players[otherId].y === deathLocation.y) {
                    killerPlayerId = otherId;
                    break;
                  }
                }
              }
            }
          }
          
          gameState = data;
          render();
          updateHUD();
          
          // Increment explosion animation frame
          if (deathFrame !== null && explosionFrames < 10) {
            explosionFrames++;
          }
          
          if (!isGameStarted) {
            isGameStarted = true;
            adjustCanvasSize();
            document.getElementById('waitingMsg').style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('mobile-controls').style.display = 'grid';
          }
        }
      };
      
      socket.onerror = function(error) {
        console.error('WebSocket error:', error);
        document.getElementById('waitingMsg').innerHTML = '<h2 style="color:#ef4444;">Connection Error</h2><p>Unable to connect to game server. Please check your connection and try refreshing.</p><button style="margin-top:16px;padding:12px 24px;background:#2a2f6b;color:#fff;border:none;border-radius:8px;cursor:pointer;" onclick="location.href=\'/matches/multiplayer/\'">Back to Lobby</button>';
      };
      
      socket.onclose = function() {
        console.log('Disconnected from game');
      };
    }

    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        return;
      }

      if (!socket || socket.readyState !== WebSocket.OPEN || !isGameStarted) return;
      
      var direction = null;
      var key = e.key.toUpperCase();
      
      if (key === 'W' || key === 'ARROWUP') direction = 'UP';
      else if (key === 'S' || key === 'ARROWDOWN') direction = 'DOWN';
      else if (key === 'A' || key === 'ARROWLEFT') direction = 'LEFT';
      else if (key === 'D' || key === 'ARROWRIGHT') direction = 'RIGHT';
      
      if (direction) {
        gameAudio.playMove(); // ADD THIS
        socket.send(JSON.stringify({
          action: 'changeDirection',
          direction: direction
        }));
      }
    });

    function render() {
      if (!gameState || !gameState.players) return;

      /* ===============================
        AUDIO / STATE CHANGE DETECTION
        =============================== */

      // Init previous state
      if (!window.prevGameState) {
        window.prevGameState = JSON.parse(JSON.stringify(gameState));
      }

      var myPlayerId = null;
      for (var id in gameState.players) {
        if (gameState.players[id].playerColor === myPlayerColor) {
          myPlayerId = id;
          break;
        }
      }

      if (
        myPlayerId &&
        window.prevGameState.players &&
        window.prevGameState.players[myPlayerId]
      ) {
        var prevMe = window.prevGameState.players[myPlayerId];
        var currMe = gameState.players[myPlayerId];

        // Score increase ‚Üí wall spawned
        if (currMe.score > prevMe.score) {
          gameAudio.playScore();
        }

        // Hit wall
        if (currMe.hits > prevMe.hits) {
          gameAudio.playHit();
        }

        // Killed someone
        for (var otherId in gameState.players) {
          if (otherId === myPlayerId) continue;

          var prevOther = window.prevGameState.players[otherId];
          var currOther = gameState.players[otherId];

          if (
            prevOther &&
            prevOther.alive &&
            !currOther.alive &&
            currMe.alive
          ) {
            gameAudio.playKill();
          }
        }

        // We died
        if (prevMe.alive && !currMe.alive) {
          gameAudio.playLoss();
        }
      }

      // Deep copy state for next frame
      window.prevGameState = JSON.parse(JSON.stringify(gameState));

      /* ===============================
        RENDERING
        =============================== */

      var playerCount = Object.keys(gameState.players).length;
      var gridSize = gameState.gridSize || 25;

      CELL_SIZE = canvas.width / gridSize;

      // Background
      ctx.fillStyle = '#121428';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;

      for (var i = 0; i <= gridSize; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }

      // Border danger zone
      ctx.fillStyle = '#ef4444';
      ctx.globalAlpha = 0.2;
      ctx.fillRect(0, 0, canvas.width, 4);
      ctx.fillRect(0, canvas.height - 4, canvas.width, 4);
      ctx.fillRect(0, 0, 4, canvas.height);
      ctx.fillRect(canvas.width - 4, 0, 4, canvas.height);
      ctx.globalAlpha = 1.0;

      // Solid walls
      ctx.fillStyle = '#ef4444';
      if (gameState.walls) {
        gameState.walls.forEach(function (w) {
          ctx.fillRect(
            w.x * CELL_SIZE + 2,
            w.y * CELL_SIZE + 2,
            CELL_SIZE - 4,
            CELL_SIZE - 4
          );
        });
      }

      // Countdown walls
      if (gameState.countdownWalls) {
        gameState.countdownWalls.forEach(function (w) {
          var alpha = 0.3 + (0.7 * (3 - w.secondsLeft)) / 3;
          ctx.fillStyle = 'rgba(239, 68, 68, ' + alpha + ')';

          ctx.fillRect(
            w.x * CELL_SIZE + 2,
            w.y * CELL_SIZE + 2,
            CELL_SIZE - 4,
            CELL_SIZE - 4
          );

          ctx.fillStyle = '#fff';
          var fontSize = Math.max(12, CELL_SIZE * 0.5);
          ctx.font = 'bold ' + fontSize + 'px system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.fillText(
            w.secondsLeft,
            (w.x + 0.5) * CELL_SIZE,
            (w.y + 0.5) * CELL_SIZE
          );
        });
      }

      // Players
      var playerEntries = Object.entries(gameState.players);
      for (var i = 0; i < playerEntries.length; i++) {
        var userId = playerEntries[i][0];
        var player = playerEntries[i][1];

        if (!player.alive) continue;

        var px = player.x * CELL_SIZE + CELL_SIZE / 2;
        var py = player.y * CELL_SIZE + CELL_SIZE / 2;

        // Highlight the killer player with a red glow
        if (killerPlayerId === userId && deathFrame !== null) {
          ctx.fillStyle = 'rgba(239, 68, 68, ' + (0.5 - (explosionFrames / 20)) + ')';
          ctx.beginPath();
          ctx.arc(px, py, CELL_SIZE * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }

        var botImg = getBotImage(player.playerColor);

        ctx.save();
        ctx.translate(px, py);

        var angle = 0;
        if (player.direction === 'DOWN') angle = Math.PI;
        else if (player.direction === 'LEFT') angle = -Math.PI / 2;
        else if (player.direction === 'RIGHT') angle = Math.PI / 2;

        ctx.rotate(angle);

        var drawSize = CELL_SIZE * 1.5;
        ctx.drawImage(
          botImg,
          -drawSize / 2,
          -drawSize / 2,
          drawSize,
          drawSize
        );

        ctx.restore();

        // Username above player
        var textSize = Math.max(10, CELL_SIZE * 0.4);
        ctx.fillStyle = '#fff';
        ctx.font = textSize + 'px system-ui';
        ctx.textAlign = 'center';

        ctx.fillText(
          player.username,
          px,
          py - CELL_SIZE / 2 - textSize - 4
        );

        // Score below player (larger and more prominent)
        var scoreSize = Math.max(14, CELL_SIZE * 0.6);
        ctx.fillStyle = player.score >= 10 ? '#fbbf24' : '#10b981';
        ctx.font = 'bold ' + scoreSize + 'px system-ui';
        ctx.fillText(
          'üí∞ ' + player.score,
          px,
          py + CELL_SIZE / 2 + scoreSize + 2
        );
      }

      // Draw explosion animation
      if (deathFrame !== null && explosionFrames < 10) {
        drawExplosion(deathLocation, CELL_SIZE, explosionFrames);
      }
    }

    function drawExplosion(location, cellSize, animFrame) {
      var px = location.x * cellSize + cellSize / 2;
      var py = location.y * cellSize + cellSize / 2;
      var maxRadius = cellSize * 1.5;
      var radius = (maxRadius / 10) * animFrame;
      
      // Outer expanding circle
      ctx.strokeStyle = 'rgba(255, 100, 0, ' + (1 - animFrame / 10) + ')';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner brighter circle
      ctx.strokeStyle = 'rgba(255, 200, 0, ' + (1 - animFrame / 10) * 0.7 + ')';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, radius * 0.6, 0, Math.PI * 2);
      ctx.stroke();
      
      // Flash at center
      ctx.fillStyle = 'rgba(255, 255, 100, ' + (1 - animFrame / 10) * 0.3 + ')';
      ctx.beginPath();
      ctx.arc(px, py, cellSize * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function updateHUD() {
      if (!gameState || !gameState.players) return;
      
      var playerList = document.getElementById('playerList');
      playerList.innerHTML = '<strong style="color:#9ca3af;font-size:12px;">PLAYERS</strong>';
      
      var sortedPlayers = Object.entries(gameState.players).sort(function(a, b) {
        return b[1].score - a[1].score;
      });
      
      for (var i = 0; i < sortedPlayers.length; i++) {
        var entry = sortedPlayers[i];
        var userId = entry[0];
        var player = entry[1];
        
        var div = document.createElement('div');
        div.className = 'player-item' + (player.alive ? '' : ' player-dead');
        
        var colorBadge = '<span class="color-badge" style="background-color:' + player.playerColor + ';"></span>';
        
        var scoreClass = player.score >= 0 ? 'score-positive' : 'score-negative';
        var scoreSign = player.score >= 0 ? '+' : '';
        
        div.innerHTML = '<span>' + colorBadge + '<span class="player-name">' + player.username + '</span></span>' +
          '<span class="player-score ' + scoreClass + '">' + scoreSign + player.score + '</span>' +
          '<span style="color:#9ca3af;font-size:11px;margin-left:4px;">(‚ùå ' + player.hits + '/50)</span>';
        
        playerList.appendChild(div);
      }
    }

    function handleGameOver(data) {
      console.log('üèÅ GAME OVER EVENT RECEIVED:', data);
      // Wait for explosion animation to finish before showing game over (10 frames * 150ms = 1500ms)
      var showGameOverDialog = function() {
        /* ===============================
          VICTORY / LOSS SOUND LOGIC
          =============================== */

        var myPlayerId = null;
        for (var id in gameState.players) {
          if (gameState.players[id].playerColor === myPlayerColor) {
            myPlayerId = id;
            break;
          }
        }

        // Victory
        if (data.winnerId && myPlayerId && data.winnerId == myPlayerId) {
          gameAudio.playVictory(); // WE WON!
        } else if (!data.isTie) {
          // Loss sound already handled on elimination in render()
          // Do nothing here to avoid double audio
        }

        /* ===============================
          FINAL SCORES UI
          =============================== */

        var finalScoresDiv = document.getElementById('finalScores');
        var winnerInfoDiv = document.getElementById('winnerInfo');

        if (data.finalScores) {
          var sortedScores = Object.entries(data.finalScores).sort(function (a, b) {
            return b[1] - a[1];
          });

          var scoresHTML = '<strong>Final Results:</strong><br>';

          for (var i = 0; i < sortedScores.length; i++) {
            var userId = sortedScores[i][0];
            var score = sortedScores[i][1];
            var hits = data.finalHits ? data.finalHits[userId] : 0;
            var player =
              gameState && gameState.players ? gameState.players[userId] : null;
            var name = player ? player.username : 'Player';

            scoresHTML +=
              '<div style="margin:6px 0;">' +
              '<span style="color:#10b981;font-weight:600;">' +
              name +
              ': +' +
              score +
              ' pts</span>' +
              '<span style="color:#9ca3af;margin-left:8px;font-size:12px;">(‚ùå ' +
              hits +
              '/50)</span>' +
              '</div>';
          }

          finalScoresDiv.innerHTML = scoresHTML;
        }

        /* ===============================
          WINNER / POT DISPLAY
          =============================== */

        if (data.isTie) {
          document.getElementById('winnerText').textContent = 'Tie Game!';

          var potAmount = {{ match.totalPot|floatformat:0 }};
          winnerInfoDiv.innerHTML =
            '<div style="font-size:16px;color:#9ca3af;">Split pot among ' + data.alivePlayers.length + ' players:</div>' +
            '<div style="margin-top:12px;font-size:24px;font-weight:700;color:#fbbf24;">üí∞ +' + 
            Math.floor(potAmount / (Object.keys(gameState.players).length)) + 
            ' coins each</div>';
        } else if (data.winnerId) {
          var winnerPlayer = gameState.players[data.winnerId];
          document.getElementById('winnerText').textContent =
            'üèÜ ' + (winnerPlayer ? winnerPlayer.username : 'Unknown') + ' Wins!';
          
          var potAmount = {{ match.totalPot|floatformat:0 }};
          winnerInfoDiv.innerHTML =
            '<div style="font-size:16px;color:#9ca3af;">Winner takes all!</div>' +
            '<div style="margin-top:12px;font-size:24px;font-weight:700;color:#fbbf24;">üí∞ +' + 
            potAmount + 
            ' coins</div>';
          winnerInfoDiv.style.display = 'block';
        }

        /* ===============================
          SHOW MODAL
          =============================== */

        document.getElementById('gameOver').style.display = 'block';
      };

      // Wait for explosion if we died, otherwise show immediately
      if (deathFrame !== null) {
        setTimeout(showGameOverDialog, 1500);
      } else {
        showGameOverDialog();
      }
    }


    connectWebSocket();

    function pressKey(key) {
      document.dispatchEvent(new KeyboardEvent('keydown', { key: key }));
    }

    function releaseKey(key) {
      document.dispatchEvent(new KeyboardEvent('keyup', { key: key }));
    }

    window.addEventListener('resize', function() {
      if (gameState && canvas.style.display !== 'none') {
        adjustCanvasSize();
        render();
      }
    });

    // Simple Web Audio API sound generator
class GameAudio {
  constructor() {
    this.audioContext = null;
    this.enabled = true;
  }
  
  init() {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  
  // Move/direction change sound - quick beep
  playMove() {
    if (!this.enabled) return;
    this.init();
    
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = 400; // Hz
    oscillator.type = 'square';
    
    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + 0.05);
  }
  
  // Wall hit sound - harsh buzz
  playHit() {
    if (!this.enabled) return;
    this.init();
    
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = 150; // Low harsh sound
    oscillator.type = 'sawtooth';
    
    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + 0.15);
  }
  
  // Score point - pleasant chime
  playScore() {
    if (!this.enabled) return;
    this.init();
    
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = 800; // High pleasant tone
    oscillator.type = 'sine';
    
    gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + 0.2);
  }
  
  // Victory - ascending celebratory notes
  playVictory() {
    if (!this.enabled) return;
    this.init();
    
    const notes = [523, 659, 784, 1047]; // C, E, G, C (octave up)
    const noteLength = 0.15;
    
    notes.forEach((freq, i) => {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = 'sine';
      
      const startTime = this.audioContext.currentTime + (i * noteLength);
      gainNode.gain.setValueAtTime(0.2, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteLength);
      
      oscillator.start(startTime);
      oscillator.stop(startTime + noteLength);
    });
  }
  
  // Loss/elimination - descending sad notes
  playLoss() {
    if (!this.enabled) return;
    this.init();
    
    const notes = [392, 330, 262]; // G, E, C (descending)
    const noteLength = 0.2;
    
    notes.forEach((freq, i) => {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = 'sine';
      
      const startTime = this.audioContext.currentTime + (i * noteLength);
      gainNode.gain.setValueAtTime(0.2, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteLength);
      
      oscillator.start(startTime);
      oscillator.stop(startTime + noteLength);
    });
  }
  
  // Kill/eliminate another player - powerful strike
  playKill() {
    if (!this.enabled) return;
    this.init();
    
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = 100;
    oscillator.type = 'sawtooth';
    
    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + 0.3);
  }
  
  toggle() {
    this.enabled = !this.enabled;
    return this.enabled;
  }
}

// Create global audio instance
const gameAudio = new GameAudio();

  function toggleSound() {
    var enabled = gameAudio.toggle();
    document.getElementById('soundBtn').textContent = enabled ? 'üîä Sound ON' : 'üîá Sound OFF';
  }
  </script>
</body>
</html>